---Building some helpful functions

--Row reduced echelon form function
--Input: a matrix defined over *any* field
--Output: the row reduced echelon form
rref = M->(
    F := ring(M);
    R := F[vars(0..(numcols M)-1)];
    V := transpose vars R;
    I := ideal(M*V);
    G := reverse flatten entries gens gb I;
    G = apply(G,g->(
	    c := (last(coefficients g))_(0,0);
	    sub(1/c,F)*g));
    T := gens R;
    matrix apply(G,g->apply(T,t->coefficient(t,g)))
    )

--Division algorithm (from CLO p.65)
divisionAlgorithm=(f,L)->(
    --get the ring in which polynomials are defined
    S := ring f;
    --initialize quotient list and remainder to zero
    quot := new MutableList from apply(L,i->0);
    rem := 0;
    p := f;
    while p != 0 do(
	i := 0;
	divisionoccurred := false;
	while i<=(length(L)-1) and not divisionoccurred do(
	    diffi := (flatten exponents leadTerm(p))-(flatten exponents leadTerm(L_i));
	    if all(diffi,i->i>=0) then(
		nqt := sub(leadTerm(p)/leadTerm(L_i),S);
		quot#i = quot#i+nqt;
		p = p-nqt*L_i;
		divisionoccurred = true;
		)else(
		i = i+1;
		));
	if not divisionoccurred then(
	    rem = rem+leadTerm(p);
	    p = p-leadTerm(p);
	    );
	);
    (toList quot,rem)	
    )

--Multiplication matrix for a ring element
--Input: a polynomial f and an ideal I (zero-dimensional!)
--Output: the multiplication matrix for f on the quotient S/I (provided I is zero-dimensional)
multiplicationMatrix = (f,I)->(
    S := ring(I);
    if dim(S/I)>0 then(
	return("Error: not a zero dimensional ideal.")
	)else(
	B := flatten entries sub(basis (S/I),S);
	M := transpose matrix apply(B,b->(
		H := (f*b)%I;
		apply(B,c->coefficient(c,H))
		));
	K := coefficientRing(S);
	(B,map(K^(numcols M),K^(numcols M),M))
	))

--Computing S-pairs
sPair=(f,g)->(
    S := ring f;
    lf := leadTerm f;
    lg := leadTerm g;
    LCM := lcm(lf,lg);
    m1 := sub(LCM/lf,S);
    m2 := sub(LCM/lg,S);
    m1*f-m2*g
    )

--Buchberger's Algorithm
